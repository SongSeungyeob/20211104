<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>javascript/set.html</title>
    </head>
    <body>
        <script>

            const letters = new Set(['a','b','c']);
            letters.add('d');
            letters.add('e');
            letters.delete('d');

            letters.forEach(function(a, b, c) {
                console.log(a, b, c);
            })
            // 배열에는 forEach문에 Index값이 존재하지만,
            // set에서의 forEach문은 (현재 값, 현재 값, thisSet)이 설정된다.
            
            let result = console.log(letters.values());  
            console.log(typeof result);
            /* set.values() : set에 있는 모든 요소 가져오기. 
               return Type이 setIterator이다. Iterator = 반복자
               하지만 ! 배열처럼 Index번호로 접근하는 것은 불가능하다.
               애초에, set.values().length가 안된다. 
             */
            for(let val of letters.values()) {
                console.log(val);
            }
            letters.add('a');
            letters.add('b');
            letters.add('c');
            console.log(letters);
            console.log(letters.values());
            // set에는 중복된 값이 들어갈 수 없다.
            
            const fruits = new Map();
            // Map = (key , value) 한 쌍으로 값으로 갖는 자료구조.
            fruits.set('apple', 500);
            fruits.set('banana', 400);
            fruits.set('cherry', 600);
            let price = fruits.get('apple');
            console.log(price);

            console.log((fruits.entries()));    // map.entries() : map에 있는 모든 요소들 보기
            for(let ent of fruits.entries()) {
                console.log(ent);  
                // entry Type은 key, value가 배열형식으로 각각 0번, 1번Index에 위치해서 return 된다.
                // ent = [ 'key', 'value' ] 와 형태가 된다.
            }
            for(let ent of fruits.entries()) {
                console.log(ent[0]);
            }
            for(let ent of fruits.entries()) {
                console.log(ent[1]);
            }

            let fruitAry = [];
            for(let ent of fruits.entries()) {
                fruitAry.push(ent);
            }
            console.log(fruitAry);

            fruits.forEach(function(a, b, c) {
                console.log(a, b, c);
            })
            /* Map Type에도 forEach Method가 존재한다.
               forEach(a, b, c)에서 a = Value값, b = Key값, c = this Map자신이 온다.
               Value값이 첫 번째 인자로 들어온다 !!
             */

            let ary = [];        // 배열의 값은 [ ] 안에. 선언식 = new Array();
            let obj = {};        // object의 값은 { } 안에. 선언식 = new Object();
            let reg = /W3Schools/;       // 정규표현식(regExp) 의 값은 / / 안에. Type = object. 선언식 = new RegExp();
            console.log(typeof reg);

            let text = "Visit W3Schools!";
            let n = text.search(reg);
            console.log(n);
            // regExp = 식을 통해서 원하는 데이터를 찾아오는 것.
            
            reg = /w3schools/;
            n = text.search(reg);   // search = 찾아오겠습니다.
            console.log(n);
            
            text = "Visit Microsoft!";
            n = text.replace("Microsoft","W3Schools");  // replace(a, b) : a를 찾아서 b로 바꾸겟다.
            console.log(n);

            text = "Visit Microsoft!";
            n = text.replace(/microsoft/i,"W3Schools");  // i 옵션을 이용하면, 대소문자 상관이 없다.
            console.log(n);

            text = "Visit Microsoft!";
            n = text.match('viSIt');
            console.log(n);
        </script>
    </body>
</html>